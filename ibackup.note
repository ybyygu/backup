#+TITLE: 系统数据自动备份
#+SETUPFILE: ~/Notes/common.org
#+TODO: TODO | DONE(@)
#+PROPERTY: mkdirp yes
#+PROPERTY: padline no

* 摘要
  * 将isync-data下的数据 *实时* 同步至isync-backup下
  * 在isync-snapshots下做快照, 保存版本信息
  * 按指数衰减算法清理isync-snapshots下的快照

* [2/3] Memo
** TODO [2015-04-18 Sat] isync-data不应该放在etc这个目录下, 可能导致无穷递归.
   放在/backup下要好很多.
** DONE [#B] [2013-07-23 Tue] lsyncd 2.1新版 无法使用之前写的config文件, 需要升级 :Action:
   - State "DONE"       from "TODO"       [2015-04-18 Sat 11:43]
** [2012-06-29 Fri]: 2.0.7版更新. 以后有空了注意与rsyncssh.lua同步

   需要处理rsyncExitCodes之类的东西. rsyncExitCodes = default.rsyncExitCodes,

** DONE [2012-06-17 Sun]: 使用牛顿冷却公式来处理文件备份的问题 [[http://songshuhui.net/archives/67391][URL]]
   - State "DONE"       from "TODO"       [2015-04-19 Sun 13:32] \\
     已应用.
** [2011-09-05 Mon]: 注意exclude文件里不能有空行, 否则所有文件都会被排除掉.

** [2011-05-19 Thu] update to lsyncd-2.0
   新版的优点:
   * 可以处理move事件, 不用像以前那样进行"delete here >> copy there"的
     操作.
   * 配置文件使用lua语法.

* 架构规划
  1. 数据目录: source_directories
     1) 基于目录+软链接的方式管理起来更方便直观些.
     2) 源目录通过软链接到source_rootdir(isync-data)下
        : isync-data/note --> ~/Notes
        其中~/Notes是真正要备份的目录: source_directory

  2. 目标目录(备份数据至..): backup_directory
     - backup_rootdir(/btrfs/backup): 用于数据备份的根目录, 所有源目录都将同步其下的
       子目录
     - backup_directory: 真正用于数据备份的目录
       如1.2中的例子:
       : backup_directory = /btrfs/backup/note
     - 如果backup_rootdir是btrfs文件系统的一个子卷(subvolume), 则可基
       于基snapshot功能, 做版本备份(TimeMachine).
     - snapshot_rootdir (/btrfs/TimeMachine): 用于在其下存储btrfs子卷
       (/btrfs/backup)快照. 应为btrfs文件系统下一普通目录.
     - 基于日期的快照命名: snapshot_rootdir/day/time
       : /btrfs/TimeMachine/2011-09-04/22:13
     - 快照清理
       - 需要自动清理旧的备份(指数衰减)
* BTRFS
  1. BTRFS 做增量备份: [[https://btrfs.wiki.kernel.org/index.php/Incremental_Backup][incremental backup]]
     "-o" 做只读版本

* install
  1. aur: lsyncd
  2. 需要lua中的lfs包 lua51-filesystem
* 多余备份的清理算法
** 流程
*** 基于指数衰减, 或牛顿冷却定律.
    其实与玻尔兹曼分布一回事.

   1. 随着时间的增加, 备份保留的意义在递减.

*** 根据存活概率确定备份的去留
    1. 选择某段时间间隔delta_t, 计算该区间内备份的数目current_snapshots
    2. 通过积分, 计算delta_t容许的备份数 allowed_snapshots
    3. 如果allowed_snapshots >= current_snapshots, 不操作. 反之清理掉
       多余的.
**** src

#+NAME: weighted-choose-one
#+BEGIN_SRC python :session test :results output
  import random
  import bisect
  import operator

  def accumulate(iterable, func=operator.add):
      it = iter(iterable)
      total = next(it)
      yield total
      for element in it:
          total = func(total, element)
          yield total

  def weighted_choose_one(choices, weights):
      """ select single one based on their weights """
      
      assert len(choices) == len(weights)
      cumdist = list(accumulate(weights))
      x = random.random() * cumdist[-1]
      return bisect.bisect(cumdist, x)

#+END_SRC

#+RESULTS: weighted-choose-one


基于权重选择多个保留项
#+NAME: weighted-choose
#+BEGIN_SRC python :session test :results output
  def weighted_choose(choices, weights, ncount):
      """ choose n-choices one time according their weights """
      
      assert len(choices) > ncount
      
      chosen = []
      for it in range(ncount):
          idx = weighted_choose_one(choices, weights)
          chosen.append(choices[idx])
          del choices[idx]
          del weights[idx]
      return sorted(chosen)

#+END_SRC

#+RESULTS: weighted-choose


**** 测试

#+tblname: table1
| choices | weights |
|---------+---------|
| dir1    |    0.99 |
| dir2    |    0.87 |
| dir3    |    0.80 |
| dir4    |    0.75 |
| dir5    |     0.7 |

#+tblname: table2
|      adirs | bdirs |
|------------+-------|
| 2015-04-19 | 22:00 |
| 2015-04-19 | 21:00 |
| 2015-04-18 | 20:01 |
| 2015-04-18 | 21:03 |
| 2015-04-17 | 12:04 |
| 2015-04-16 | 11:05 |
| 2015-04-13 | 12:06 |
| 2015-03-13 | 12:07 |

#+begin_src python :var adirs=table2[,0] :var bdirs=table2[,1] :results output :session test
  from __future__ import division
  import datetime

  max_hours = 500
  max_snapshots = 80
  now = datetime.datetime.now()
  hours_list = [ ]

  choices = []
  weights = []

  def snapshot_dir_to_datetime(day_dir, time_dir):
      return datetime.datetime.strptime("{}/{}".format(day_dir, time_dir), "%Y-%m-%d/%H:%M")

  def calc_snapshot_score(day_dir, time_dir):
      delta = now - snapshot_dir_to_datetime(day_dir, time_dir)
      hours = delta.total_seconds() / 3600
      #print(hours)
      return evaluate_decay_score(hours, max_snapshots)

  for adir, bdir in zip(adirs, bdirs):
      score = calc_snapshot_score(adir, bdir)
      #print("{}/{}: {:.2f}".format(adir, bdir, score))
      choices.append((adir, bdir))
      weights.append(score)

  def calc_allowed_snapshots(choices):
      """ calculate how many snapshots allowed to keep """
      
      assert len(choices) >= 2
      first, last = choices[0], choices[-1]
      
      d1 = (now - snapshot_dir_to_datetime(*last)).total_seconds() / 3600
      d2 = (now - snapshot_dir_to_datetime(*first)).total_seconds() / 3600
      return evaluate_decay_area(d1, d2, max_snapshots)


  def bichoose(ichoices, current=None):
      if current is None:
          choice1 = next(ichoices)
      else:
          choice1 = current
          
      finished = False
      for choice2 in ichoices:
          allowed = calc_allowed_snapshots([choice1, choice2])
          print("{} {} {:.1f}".format(choice1[-1], choice2[-1], allowed))
          if allowed >= 1:
              score1 = calc_snapshot_score(*choice1)
              score2 = calc_snapshot_score(*choice2)
              #idx = weighted_choose_one([choice1, choice2], [score1, score2])
              #yield choice1 if idx == 0 else choice2
              yield choice1
              break
      else:
          finished = True
          yield choice1
          
      if not finished:
          for c in bichoose(ichoices, current=choice2):
              yield c

  ichoices = iter(choices)

  for c in bichoose(ichoices):
      print(c)

#+end_src

#+RESULTS:
#+begin_example

>>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> ... ... >>> ... ... ... ... ... >>> ... ... ... ... ... >>> ... ... ... ... ... ... ... ... ... >>> >>> ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... >>> >>> >>> ... ... 22:00 21:00 0.8
22:00 20:01 17.4
('2015-04-19', '22:00')
20:01 21:03 0.6
20:01 12:04 14.9
('2015-04-18', '20:01')
12:04 11:05 8.1
('2015-04-17', '12:04')
11:05 12:06 13.1
('2015-04-16', '11:05')
12:06 12:07 9.1
('2015-04-13', '12:06')
('2015-03-13', '12:07')
#+end_example

** src

#+NAME: evalue-decay
#+BEGIN_SRC python :results output :session test :cache no
  from __future__ import division
  import math

  def evaluate_decay_score(elapsed, kbt=600*0.083145):
      """ use Boltzmann distribution instead """
      
      assert elapsed >= 0 and kbt > 0
      
      score = math.exp(-1*elapsed / kbt)
      return score

  def evaluate_decay_area(point_from, point_to, kbt=600*0.083145):
      """ the Boltzmann distribution aread """
      
      if point_from > point_to:
          point_from, point_to = point_to, point_from
      
      s1 = math.exp(-1*point_from / kbt)
      s2 = math.exp(-1*point_to / kbt)
      return (s1 - s2)*kbt
#+END_SRC

#+RESULTS: evalue-decay

测试下看:
#+BEGIN_SRC python :session test :results output :cache no
  print(evaluate_decay_score(0, 300))
  print(evaluate_decay_score(10, 30))
  print(evaluate_decay_area(0, 500, 80))
#+END_SRC

#+RESULTS:
: 1.0
: 0.716531310574
: 79.8455636691


#+BEGIN_SRC python :session test :results output :cache no
  max_days = 500
  max_snapshots = 80
  print(evaluate_decay_area(0, max_days, max_snapshots))

  def itp(idays, current=None):
      # the starting point
      if current is None:
          d1 = next(idays)
          yield d1
      else:
          d1 = current
      
      # indicate if idays has been exhausted
      empty = True
      for d2 in idays:
          empty = False
          s = evaluate_decay_area(d1, d2, max_snapshots)
          #print("{}-{} = {:.2f}".format(d1, d2, s))
          if s >= 1:
              break
      else:
          empty = True
          
      if not empty:
          yield d2
          for p in itp(idays, current=d2):
              yield p

  idays = iter(range(max_days))
  for d in itp(idays):
      print(d)

#+END_SRC

#+RESULTS:
#+begin_example

>>> 79.8455636691
>>> ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... >>> >>> ... ... 0
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40
42
44
46
48
50
52
54
56
59
62
65
68
71
74
77
80
83
86
89
93
97
101
105
109
114
119
124
129
135
141
148
155
163
172
182
193
206
221
239
262
295
351
#+end_example
* logger
#+NAME: logger
#+BEGIN_SRC python :session test
  import logging

  LogThemeNull = logging.Formatter(
      " %(message)s")
  LogThemeSimple = logging.Formatter(
      "[%(levelname)s] %(message)s")
  LogThemeClean = logging.Formatter(
      "[%(name)s|%(lineno)04d %(levelname)s] %(message)s")
  LogThemeClean2 = logging.Formatter(
      "[%(name)s|%(lineno)04d %(levelname)5s %(asctime)s] %(message)s", datefmt="%Y-%m-%d %H:%M:%S")
  LogThemeFull = logging.Formatter(
      "\n%(asctime)s - %(name)s.%(funcName)s, line %(lineno)d\n" \
      + "-"*80 + "\n [%(levelname)s] %(message)s",
      datefmt="%Y-%m-%d %H:%M:%S")

  class ConsoleHandler(logging.StreamHandler):
      """
      log messages to console screen
      >> direct logging.error and above to stderr, others to stdout
      """
      def __init__(self, *args, **kwargs):
          logging.StreamHandler.__init__(self, *args, **kwargs)

      def emit(self, record):
          if record.levelno >= logging.WARN:
              self.stream = sys.stderr
          else:
              self.stream = sys.stdout
          logging.StreamHandler.emit(self, record)

  def setup_logger(name=None, theme="null", logfile=None, verbose=True, root=False):
      """ if name is empty, you get the root logger
      @root: root logger of not
      """
      
      Themes = {"clean":LogThemeClean,
                "clean2": LogThemeClean2,
                "simple":LogThemeSimple,
                "null":LogThemeNull,
                "full":LogThemeFull
                }

      # make levelname shorter
      if theme in ("clean", "simple"):
          logging.addLevelName(logging.DEBUG, "D")
          logging.addLevelName(logging.INFO, "I")
          logging.addLevelName(logging.WARN, "W")
          logging.addLevelName(logging.ERROR, "E")

      if name and not root:
          log = logging.getLogger(name)
      else:
          log = logging.getLogger()
          
      logger.setLevel(logging.DEBUG)
      
      # keep console screen clean
      console_hdlr = ConsoleHandler()
      if verbose:
          console_hdlr.setLevel(logging.DEBUG)
      else:
          console_hdlr.setLevel(logging.INFO)
      theme = Themes[theme.lower()]
      console_hdlr.setFormatter(theme)
      logger.addHandler(console_hdlr)

      # send debug info to logfile in full details
      if logfile is None:
          logfile = "/dev/null"
      else:
          dirname = os.path.dirname(logfile)
          if dirname and not os.path.exists(dirname):
              os.makedirs(dirname)
      # use delay to avoid empty log file
      # TODO: delay argument requires python27
      # log_hdlr = logging.FileHandler(logfile, mode="w", delay=True)
      log_hdlr = logging.FileHandler(logfile, mode="w")
      log_hdlr.setLevel(logging.DEBUG)
      log_hdlr.setFormatter(Themes["clean2"])
      logger.addHandler(log_hdlr)

      # replace excepthook with logger
      def log_exception(exc_type, exc_value, traceback):
          logger.error("Oops! We run into troubles:\n>>>")
          logger.error(exc_value, exc_info=(exc_type, exc_value, traceback))
      sys.excepthook = log_exception
   
      return log

#+END_SRC

#+RESULTS:


#+RESULTS:
: 
: >>> >>> >>>  test info
: INFO  test@l1    test info
: test debug
: DEBUG test@l1    test debug

* src
** 启动lsyncd
#+BEGIN_SRC sh :tangle scripts/start-lsyncd.sh :shebang #! /usr/bin/env bash :results none
  # get real script path
  script_path="$0"
  [[ -h "$script_path" ]] && script_path=$(readlink "$script_path")

  script_root=$(cd $(dirname "$script_path"); pwd)
  echo "script root is: \"$script_root\""
  cd "$script_root"

  while true; do
      lsyncd -nodaemon -delay 30 -log all lsyncd.lua
      # sleep 5
      exit 0
  done
#+END_SRC

** lsyncd配置文件
*** 笔记
   需要安装: lua-filesystem

   见源代码中default.lua, default.checkgauge
#+BEGIN_EXAMPLE
--
-- used to ensure there aren't typos in the keys
--
default.checkgauge = {
	action        =  true,
	checkgauge    =  true,
	collect       =  true,
	delay         =  true,
	exitcodes     =  true,
	init          =  true,
	maxDelays     =  true,
	maxProcesses  =  true,
	onAttrib      =  true,
	onCreate      =  true,
	onModify      =  true,
	onDelete      =  true,
	onStartup     =  true,
	onMove        =  true,
	prepare       =  true,
	source        =  true,
	target        =  true,
}
#+END_EXAMPLE
   1. sync函数是主要的入口
   2. 几个重要的子函数
      1. init
      2. action
      3. collect
      4. prepare
   3. 默认的事件处理函数
      1. OnStartup
      2. OnAttrib
      3. OnCreate
      4. OnDelete
      5. OnModify
      6. OnMove
   4. default.action ==> onMove, onDelete ...
*** src
#+BEGIN_SRC lua :tangle scripts/isync.lua
-----
-- My configuration file for lsyncd.
-- This needs lsyncd 2.1
--
--

require("lfs")

local source_rootdir = lfs.currentdir() .. "/scratch"
local backup_rootdir = "/btrfs/backup"
local snapshot_rootdir = "/btrfs/TimeMachine"


settings {
    logfile    = "/tmp/lsyncd.log",
    statusFile = "/tmp/lsyncd.status",
	statusInterval = 1,
    nodaemon   = true,
    maxDelays = 15,
}

---
-- record file change events and make btrfs snapshots accordingly
--
iman = {
    ---
    -- take snapshot when max_hits reached
    max_hits = 3,

    current_hits = 0,

    ---
    -- make btrfs snapshots
    --
    take_snapshot = function(event)
        log("Normal", "taking snapshot...")
        log("Normal", "./take-snapshot.py " .. backup_rootdir .. " " .. snapshot_rootdir)
        os.execute("./take-snapshot.py " .. backup_rootdir .. " " .. snapshot_rootdir)
     end,

    ---
    -- record hits
    --
    hit = function(event)
        iman.current_hits = iman.current_hits + 1
        log("Normal", "hitted as " .. iman.current_hits)
        ---
        -- reset hits
        --
        if iman.current_hits >= iman.max_hits then
            iman.current_hits = 0
            iman.take_snapshot(event)
        end
    end
}

local isync = default.rsync

isync.checkgauge.onMove = true

-- called when a process exited.
-- this can be a rsync command, the startup rsync or the postcmd
isync.collect = function(agent, exitcode)
    log("Normal", "collecting here")
	if not agent.isList and agent.etype == 'Init' then
        log("Normal", "init procedure")
    else
        log("Normal", "iman hit")
        iman.hit(agent)
    end
    --- everything else, forward to default collection handler
    return default.collect(agent,exitcode)
end


for afile in lfs.dir(source_rootdir) do
    if afile ~= '.' and afile ~= '..' then
        local path = source_rootdir .. "/" .. afile
        local attr = lfs.attributes(path, "mode")
        if attr == "directory" then
            source_dir = path
            target_dir = backup_rootdir .. "/" .. afile
            -- log("Normal", source_dir .. " ==> " .. target_dir )
            sync{isync, source=source_dir, target=target_dir, excludeFrom = "isync.exclude"}
        end
    end
end

#+END_SRC
** btrfs快照管理  [[elisp:(org-babel-tangle)][输出]]
*** overview
#+NAME: overview
#+HEADER: :session test
#+HEADER: :shebang #! /usr/bin/env python2
#+HEADER: :results output
#+BEGIN_SRC python :noweb yes :tangle scripts/snapman.py
  <<header>>

  <<imports>>

  <<setup-logger>>

  <<snapshot-manager>>

  <<main-function>>

#+END_SRC

#+RESULTS:
: 
: ... ... ... ... ... ... ... ... ... ... ... ... >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... >>> ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... >>> ... ... 0
*** imports
#+NAME: imports
#+BEGIN_SRC python :session test
  import os
  import sys
  import time
  import datetime
  import subprocess
  import math
  import random
  import re
  import logging
#+END_SRC

#+RESULTS: imports

*** header
#+NAME: header
#+BEGIN_SRC python
  # -*- coding: utf-8 -*-
  #====================================================================#
  #   DESCRIPTION:  btrfs snapshot dwim
  # 
  #       OPTIONS:  ---
  #  REQUIREMENTS:  ---
  #         NOTES:  ---
  #        AUTHOR:  Wenping Guo (ybyygu) 
  #         EMAIL:  winpng@gmail.com
  #       LICENCE:  GPL version 2 or upper
  #       CREATED:  2015-04-20 17:51
  #       UPDATED: 
  #====================================================================#

  __VERSION__ = '0.1.0'
  __UPDATED__ = '2015-04-20 17:52'


#+END_SRC
*** setup logger
#+NAME: yaml-conf
#+BEGIN_SRC python :session test
YAML_CONF = """
  version: 1
  disable_existing_loggers: true

  root:
    level: !!python/name:logging.NOTSET
    handlers: [logfile, console]

  handlers:
      logfile:
        class: logging.FileHandler
        filename: isync.log
        formatter: simpleFormatter
        delay: True
        level: !!python/name:logging.NOTSET
      console:
        class: logging.StreamHandler
        stream: ext://sys.stdout
        formatter: simpleFormatter
        level: !!python/name:logging.NOTSET

  formatters:
    simpleFormatter:
      class: !!python/name:logging.Formatter
      format: '%(levelname)-05s %(name)s@l%(lineno)-4d %(message)s'
      datefmt: '%d/%m/%Y %H:%M:%S'
"""
#+END_SRC

#+RESULTS: yaml-conf

#+NAME: setup-logger
#+BEGIN_SRC python :session test :results output
  from guts import setup_logger

  logger = setup_logger("isync")

  logger.info("test info")
  logger.debug("test debug")

#+END_SRC
    
#+RESULTS: setup-logger
: 
: >>> >>> >>>  test info
:  test info
: test debug
:  test debug

*** SnapshotManager
**** tangle
#+NAME: snapshot-manager
#+BEGIN_SRC python :results output :session test :noweb yes
  class SnapshotManager(object):
      def __init__(self, target_subvolume, snapshot_rootdir, max_snapshots_per_day=20, max_snapshot_hits=4, max_snapshots_total=80):
          self.target_subvolume = target_subvolume
          self.snapshot_rootdir = snapshot_rootdir
          self.max_snapshots_per_day = max_snapshots_per_day
          
          self._snapshot_hits = 0
          self.max_snapshot_hits = max_snapshot_hits
          self.max_snapshots_total = max_snapshots_total
          
      <<take-snapshot>>
      
      <<delete-snapshot>>
      
      <<trim-snapshots>>
#+END_SRC

#+RESULTS: snapshot-manager

**** take snapshot
     BARFS 快照.
     1. 根据当前的时间, 确定快照保存的目录名: snapshot_dirname.
     2. 如果同名的快照已存在, 则不操作.
     3. 使用"sudo btrfs subvolume snapshot" 来制作快照.
        1. 参数1 目标子卷名: target_subvolume
        2. 参数2 快照保存目录: snapshot_dirname

#+NAME: take-snapshot
#+BEGIN_SRC python :results none
  def take_snapshot(self):
      """ take one single btrfs snapshot """
      
      snapshot_parent_dir = os.path.join(self.snapshot_rootdir, time.strftime("%Y-%m-%d"))
      
      if not os.path.exists(snapshot_parent_dir):
          os.makedirs(snapshot_parent_dir)
          logger.info("Created snapshot directory: {}".format(snapshot_parent_dir))

      ##
      # take snapshot only when there is no directory named as snap_name
      # --------------------------------------------------------------------
      dirname = "{}:{:02}".format(time.strftime("%H"), int(time.strftime("%M")))
      snap_name = os.path.join(snapshot_parent_dir, dirname)
      logger.debug("snapshot directory: {}".format(snap_name))
      
      if not os.path.isdir(snap_name):
          args = "btrfs subvolume snapshot".split()
          args.append(self.target_subvolume)
          args.append(snap_name)        
          logger.info("Called with: {}".format(" ".join(args)))
          try:
              subprocess.check_call(args)
          except subprocess.CalledProcessError:
              logger.exception("Failed to take snapshot with btrfs!")
              raise
      else:
          logger.debug("Delayed for {}".format(snap_name))

#+END_SRC

**** delete snapshot
#+NAME: delete-snapshot
#+BEGIN_SRC python :results none
  def delete_snapshot(self, snapshot_path):
      """ delete one single snapshot specified by snapshot_path """
      
      if not os.path.exists(snapshot_path):
          msg ="snapshot directory {} does not exists!".format(snapshot_path)
          logger.error(msg)
          raise RuntimeError(msg)

      args = "btrfs subvolume delete".split()
      args.append(snapshot_path)
      logger.debug("cmdline: {}".format(" ".join(args)))
      try:
          subprocess.check_call(args)
          logger.info("snapshot removed.")
      except subprocess.CalledProcessError:
          logger.exception("Failed to delete btrfs snapshot!")
          raise

#+END_SRC

**** trim snapshots
#+NAME: trim-snapshots
#+BEGIN_SRC python
  def trim_snapshots(self, maxdays=15, maxdel=2):
      """ trim outdated snapshots with some intelligence

      equation: 1 - log(seq, base)
      seq: elapsed_days
      base: maxdays
      """
      
      logger.info("no implemented yet.")

#+END_SRC

**** tests
#+BEGIN_SRC python :session test :noweb eval :results output
  <<overview>>

  snapman = SnapshotManager("/btrfs/backup", "/tmp/scratch")
  snapman.take_snapshot()
  snapman.delete_snapshot("/tmp/scratch/aa")
#+END_SRC

#+RESULTS:
#+begin_example

... ... ... ... ... ... ... ... ... ... ... ... >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>> >>>  test info
 test info
 test info
 test info
 test info
 test info
test debug
 test debug
 test debug
 test debug
 test debug
 test debug
>>> >>> ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... >>> ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... >>> ... ... 0
>>> >>> >>>  snapshot directory: /tmp/scratch/2015-04-21/13:35
 snapshot directory: /tmp/scratch/2015-04-21/13:35
 snapshot directory: /tmp/scratch/2015-04-21/13:35
 snapshot directory: /tmp/scratch/2015-04-21/13:35
 snapshot directory: /tmp/scratch/2015-04-21/13:35
 snapshot directory: /tmp/scratch/2015-04-21/13:35
 Called with: btrfs subvolume snapshot /btrfs/backup /tmp/scratch/2015-04-21/13:35
 Called with: btrfs subvolume snapshot /btrfs/backup /tmp/scratch/2015-04-21/13:35
 Called with: btrfs subvolume snapshot /btrfs/backup /tmp/scratch/2015-04-21/13:35
 Called with: btrfs subvolume snapshot /btrfs/backup /tmp/scratch/2015-04-21/13:35
 Called with: btrfs subvolume snapshot /btrfs/backup /tmp/scratch/2015-04-21/13:35
 Called with: btrfs subvolume snapshot /btrfs/backup /tmp/scratch/2015-04-21/13:35
ERROR: error accessing '/btrfs/backup'
 Failed to take snapshot with btrfs!
Traceback (most recent call last):
  File "<stdin>", line 33, in take_snapshot
  File "/usr/lib/python2.7/subprocess.py", line 540, in check_call
    raise CalledProcessError(retcode, cmd)
CalledProcessError: Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
 Failed to take snapshot with btrfs!
Traceback (most recent call last):
  File "<stdin>", line 33, in take_snapshot
  File "/usr/lib/python2.7/subprocess.py", line 540, in check_call
    raise CalledProcessError(retcode, cmd)
CalledProcessError: Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
 Failed to take snapshot with btrfs!
Traceback (most recent call last):
  File "<stdin>", line 33, in take_snapshot
  File "/usr/lib/python2.7/subprocess.py", line 540, in check_call
    raise CalledProcessError(retcode, cmd)
CalledProcessError: Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
 Failed to take snapshot with btrfs!
Traceback (most recent call last):
  File "<stdin>", line 33, in take_snapshot
  File "/usr/lib/python2.7/subprocess.py", line 540, in check_call
    raise CalledProcessError(retcode, cmd)
CalledProcessError: Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
 Failed to take snapshot with btrfs!
Traceback (most recent call last):
  File "<stdin>", line 33, in take_snapshot
  File "/usr/lib/python2.7/subprocess.py", line 540, in check_call
    raise CalledProcessError(retcode, cmd)
CalledProcessError: Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
 Failed to take snapshot with btrfs!
Traceback (most recent call last):
  File "<stdin>", line 33, in take_snapshot
  File "/usr/lib/python2.7/subprocess.py", line 540, in check_call
    raise CalledProcessError(retcode, cmd)
CalledProcessError: Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
 Oops! We run into troubles:
>>>
 Oops! We run into troubles:
>>>
 Oops! We run into troubles:
>>>
 Oops! We run into troubles:
>>>
 Oops! We run into troubles:
>>>
 Oops! We run into troubles:
>>>
 Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 33, in take_snapshot
  File "/usr/lib/python2.7/subprocess.py", line 540, in check_call
    raise CalledProcessError(retcode, cmd)
CalledProcessError: Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
 Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 33, in take_snapshot
  File "/usr/lib/python2.7/subprocess.py", line 540, in check_call
    raise CalledProcessError(retcode, cmd)
CalledProcessError: Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
 Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 33, in take_snapshot
  File "/usr/lib/python2.7/subprocess.py", line 540, in check_call
    raise CalledProcessError(retcode, cmd)
CalledProcessError: Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
 Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 33, in take_snapshot
  File "/usr/lib/python2.7/subprocess.py", line 540, in check_call
    raise CalledProcessError(retcode, cmd)
CalledProcessError: Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
 Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 33, in take_snapshot
  File "/usr/lib/python2.7/subprocess.py", line 540, in check_call
    raise CalledProcessError(retcode, cmd)
CalledProcessError: Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
 Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 33, in take_snapshot
  File "/usr/lib/python2.7/subprocess.py", line 540, in check_call
    raise CalledProcessError(retcode, cmd)
CalledProcessError: Command '['btrfs', 'subvolume', 'snapshot', '/btrfs/backup', '/tmp/scratch/2015-04-21/13:35']' returned non-zero exit status 1
snapshot directory /tmp/scratch/aa does not exists!
 snapshot directory /tmp/scratch/aa does not exists!
 snapshot directory /tmp/scratch/aa does not exists!
 snapshot directory /tmp/scratch/aa does not exists!
 snapshot directory /tmp/scratch/aa does not exists!
 snapshot directory /tmp/scratch/aa does not exists!
 Oops! We run into troubles:
>>>
 Oops! We run into troubles:
>>>
 Oops! We run into troubles:
>>>
 Oops! We run into troubles:
>>>
 Oops! We run into troubles:
>>>
 Oops! We run into troubles:
>>>
 snapshot directory /tmp/scratch/aa does not exists!
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 47, in delete_snapshot
RuntimeError: snapshot directory /tmp/scratch/aa does not exists!
 snapshot directory /tmp/scratch/aa does not exists!
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 47, in delete_snapshot
RuntimeError: snapshot directory /tmp/scratch/aa does not exists!
 snapshot directory /tmp/scratch/aa does not exists!
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 47, in delete_snapshot
RuntimeError: snapshot directory /tmp/scratch/aa does not exists!
 snapshot directory /tmp/scratch/aa does not exists!
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 47, in delete_snapshot
RuntimeError: snapshot directory /tmp/scratch/aa does not exists!
 snapshot directory /tmp/scratch/aa does not exists!
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 47, in delete_snapshot
RuntimeError: snapshot directory /tmp/scratch/aa does not exists!
 snapshot directory /tmp/scratch/aa does not exists!
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 47, in delete_snapshot
RuntimeError: snapshot directory /tmp/scratch/aa does not exists!
#+end_example

*** main function
#+NAME: main-function
#+BEGIN_SRC python  :session test :results output
  def main(argv=None):
      import optparse
      
      if argv == None: argv = sys.argv
      
      # parsing cmdline
      cmdl_usage = 'usage: %prog [options]...'
      cmdl_version = "%prog " + __VERSION__ + "; updated at: " + __UPDATED__
      cmdl_parser = optparse.OptionParser(usage=cmdl_usage, \
                                          version=cmdl_version, \
                                              conflict_handler='resolve')
      cmdl_parser.add_option('-h', '--help', 
                              action='help',
                              help='print this help text and exit')
      cmdl_parser.add_option('-v', '--version', 
                              action='version', 
                              help='print program version and exit')
      (cmdl_opts, cmdl_args) = cmdl_parser.parse_args()
      
      return 0

  if __name__ == '__main__':
      main()

#+END_SRC
